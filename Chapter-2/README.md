# 2. Сортировка выбором

___

- 2 основные структуры данных, которые используются буквально везде - масивы и связанные списки. Объясняются плюсы и минусы обеих структур.
- Алгоритм сортировки.

___

### Как работает память

Память компьютера представляет собой нечто вроде огромного шкафа с множеством ящиков, и у каждого ящика есть адрес.

Каждый раз, когда вы хотите сохранить в памяти отдельное значение, вы запрашиваете у компьютера место в памяти, а он выдает адрес для сохранения значения.

### Массивы и связанные списки

Иногда в памяти требуется сохранить список элементов.

При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом).

Если мы захотели добавить еще задачу, но следующий ящик уже занят. Придётся искать новое место, где смогут рядом разместиться все задачи. В этом случае придется запросить у компьютера другой блок памяти, а потом переместить все свои задачи туда.

Связанные списки решают проблему добавления новых элементов. При использовании связанного списка элементы могут размещаться где угодно в памяти.

В каждом элементе хранится адрес следующего элемента списка. Таким образом, набор произвольных адресов памяти объединяется в цепочку.

Связанные списки  отлично подходят в тех ситуациях, когда данные должны читаться последовательно: сначала вы читаете один элемент, по адресу переходите к следующему элементу и т. д. Но если вы намерены прыгать по списку туда-сюда, держитесь подальше от связанных списков.

### Массивы

Работая с массивом, вы заранее знаете адрес каждого его элемента. Массивы прекрасно подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно.

__Время выполнения основных операций с массивами и списками:__

- Массивы - чтение (О(1)), вставка (О(n)), удаление (О(n)).
- Списки - чтение (О(n)), вставка (О(1)), удаление (О(1)).

О(n) - _линейное время_.
О(1) - _постоянное время_.

__Упражнение:__

Допустим, вы строите приложение для управления финансами.

1. продукты
2. кино
3. велосипедный клуб

Ежедневно вы записываете все свои траты. В конце месяца вы анализируете расходы и вычисляете, сколько денег было потрачено. При работе с данными выполняется множество операций вставки и относительно немного операций чтения. Какую структуру использовать - массив или список? 

_Ответ:_

Список. Быстрое добавление заранее неизвестного объёма данных и можно не обращать внимания на время поиска (т. к. чтения мало). Массив же предназначен для фиксированного кол-ва записей.

### Вставка в середину списка

Со списком задача решается изменением указателя в предыдущем элементе.

А при работе с массивом придется сдвигать вниз все остальные элементы. А если свободного места не осталось, все данные придется скопировать в новую область памяти.

__Списки лучше подходят для вставки элементов в середину.__

### Удаление

И снова список лучше подходит для этой операции, потому что в нем достаточно изменить указатель в предыдущем элементе. В массиве при удалении элемента все последующие элементы нужно будет сдвинуть вверх.

#### Итог

__Массивы__ чрезвычайно популярны из-за того, что они поддерживают произвольный доступ. Всего существует 2 вида доступа: _произвольный_ и _последовательный_.

Связанные списки поддерживают только последовательный доступ.

__Упражнение:__

1. Допустим, вы пишете приложение для приема заказов от посетителей ресторана. Приложение должно хранить список заказов. Официанты добавляют заказы в список, а повара читают заказы из списка и выполняют их. Заказы образуют очередь: официанты добавляют заказы в конец очереди, а повар берет первый заказ из очереди и начинает готовить. Какую структуру данных вы бы использовали для реализации этой очереди: массив или связанный список? (Подсказка: связанные списки хорошо подходят для вставки/удаления, а массивы - для произвольного доступа к элементам. Что из этого понадобится в данном случае?).

_Ответ:_

Связанные списки. Очередь на основе связанного списка будет лучшим вариантом для ответа на заданный выше вопрос. В очереди связанного списка у вас есть преимущество операции O (1) для вставки (размещение заказов серверами) и удаления (принятие заказов шеф-поваром). Кроме того, у вас есть динамическое распределение памяти (память используется только тогда, когда это необходимо).

2. Проведем мысленный эксперимент. Допустим, Facebook хранит список имен пользователей. Когда кто-то пытается зайти на сайт Facebook, система пытается найти имя пользователя. Если имя входит в список имен зарегистрированных пользователей, то вход разрешается. Пользователи приходят на Facebook достаточно часто, поэтому поиск по списку имен пользователей будет выполняться часто. Будем считать, что Facebook использует бинарный поиск для поиска в списке. Бинарному поиску необходим произвольный доступ - алгоритм должен мгновенно обратиться к среднему элементу текущей части списка. Зная это обстоятельство, как бы вы реализовали список пользователей: в виде массива или в виде связанного списка?

_Ответ:_

 В виде отсортированного массива. Массивы обеспечивают произвольный доступ — вы можете мгновенно получить элемент из середины массива. Со связанными списками это невозможно. Чтобы получить элемент из середины связанного списка, вам придется начать с первого элемента и переходить по ссылкам до нужного элемента.

3. Пользователи также довольно часто создают новые учетные записи на Facebook. Предположим, вы решили использовать массив для хранения списка пользователей. Какими недостатками обладает массив для выполнения вставки? Допустим, вы используете бинарный поиск для нахождения учетных данных. Что произойдет при добавлении новых пользователей в массив?

_Ответ:_

- Операции вставки и удаления в массиве выполняются медленнее при увеличении количества элементов.

- Если необходимо вставить новый элемент в статический массив, который полностью заполнен активными элементами, то произойдет ошибка времени выполнения. Если свободного места нет и вам каждый раз приходится перемещаться в новую область в памяти, операция добавления нового элемента будет выполняться очень медленно.

В случае с бинарным поиском:

- При работе с массивами придется сдвигать вниз все остальные элементы, если мы будем использовать вставку в середину списка.

- При удалении элемента все последующие элементы нужно будет сдвигать вверх.

4. В действительности Facebook не использует ни массив, ни связанный список для хранения информации о пользователях. Рассмотрим гибридную структуру данных: массив связанных списков. Имеется массив из 26 элементов. Каждый элемент содержит ссылку на связанный список. Например, первый элемент массива указывает на связанный список всех имен пользователей, начинающихся на букву "А". Второй элемент указывает на связанный список всех имен пользователей, начинающихся на букву "В" и т. д.

Теперь сравните эту гибридную структуру с массивами и связанными списками. Будет ли она быстрее или медленнее каждой исходной структуры при поиске и вставке? Приводить "Big O" не нужно, просто выберите одно из двух: быстрее или медленнее.

_Ответ:_

Быстрее.

### Сортировка выбором

При использовании этого алгоритма массив делится на две части –отсортированную и несортированную. Сортированный список находится вначале. Все элементы справа от последнего отсортированного элемента считаются несортированными.

Изначально отсортированный список пуст. Затем перебирается несортированный список и определяется самый маленький или самый большой элемент. Затем отсортированный подсписок расширяется для включения этого элемента.

После этого программа снова находит подходящий элемент, меняя его на крайний левый элемент несортированного списка и расширяя отсортированный список.

Допустим, у вас на компьютере записана музыка и для каждого исполнителя хранится счетчик воспроизведений.

Отсортируем список по убыванию счетчика воспроизведения. Одно из возможных решений - пройти по списку и найти исполнителя с наибольшим количеством воспроизведений. Этот исполнитель добавляется в новый список. Потом то же самое происходит со следующим по количеству воспроизведений исполнителем. Продолжая действовать так, мы получаем отсортированный список.

Чтобы найти исполнителя с наибольшим значением счетчика воспроизведения, необходимо проверить каждый элемент в списке. Это делается за время __О(n)__. Итак, имеется операция, выполняемая за время __О(n)__, и ее необходимо выполнить __n__ раз.

Все это требует времени __О(n * n)__ или __О(n ** 2)__.

Алгоритм сортировки выбором легко объясняется, но медленно работает.

### Шпаргалка

- Память компьютера напоминает огромный шкаф с ящиками.
- Если вам потребуется сохранить набор элементов, воспользуйтесь массивом или списком.
- В массиве все элементы хранятся в памяти рядом друг с другом.
- В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.
- Массивы обеспечивают быстрое чтение.
- Списки обеспечивают быструю вставку и удаление.
- Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т.д.).
