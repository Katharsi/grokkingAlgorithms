# Рекурсия

___

- Что такое рекурсия - метод программирования, используемый во многих алгоритмах.

- Вы научитесь разбивать задачи на базовый и рекурсивный случай. В стратегии "разделяй и властвуй" эта простая концепция используется для решения более сложных задач.

___

_Рекурсия_ - элегантный метод решения задач.

_Псевдокод_ представляет собой высокоуровневое описание решаемой задачи. Он записывается в форме, похожей на программный код, но в большей степени напоминает естественный язык.

_Рекурсией_ называется вызов функцией самой себя.

Алгоритм по поиску ключа в коробках на Python.

```Python

def look_for_key(box):
  for item in box:
    if item.is_a_box():
      look_for_key(item)
    elif item.is_a_key():
      print "found the key!"
```

цитата Ли Колдуэлла: "Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации!"

Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая. В рекурсивном случае функция вызывает сама себя. В базовом случае функция себя не вызывает... чтобы предотвратить зацикливание.

Пример:

```Python
def countdown(i):
    print i
    if i <= 1:   # Базовый случай
        return
    else:        # Рекурсивный случай
        countdown(i - 1)
```

### Стек

Стек - простая структура данных. Концепция стека вызовов играет важную роль в программировании вообще.

### Стек вызовов

Во внутренней работе вашего компьютера используется стек, называемый стеком вызовов. Давайте посмотрим, как он работает. Предположим, имеется простая функция:

```Python
def greet(name):
    print "hello, " + name + "!"
    greet2(name)
    print "getting ready to say bye..."
    bye()
```

Эта функция приветствует вас, после чего вызывает две другие функции.

Вот эти 2 функции:

```Python
def greet2(name):
    print "how are you, " + name + "?"
def bye():
    print "ok bye"
```

Предположим, в программе используется вызов ```greet('maggie')```. Сначала ваш компьютер выделяет блок памяти для этого вызова функции.

Затем эта память используется. Переменной ```name``` присваивается значение ```"maggie"```, оно должно быть сохранено в памяти.

Каждый раз, когда вы вызываете функцию, компьютер сохраняет в памяти значения всех переменных для этого вызова. Далее выводится приветствие ```hello, maggie!```, после чего следует второй вызов ```greet2('maggie')```. И снова компьютер выделяет блок памяти для вызова функции.

Ваш компьютер объединяет эти блоки в __стек__. Второй блок создается над первым. Вы выводите сообщение ```how are you, maggie?```, после чего возвращаете управление из вызова функции. Когда это происходит, блок на вершине стека извлекается из него.

Теперь верхний блок в стеке относится к функции ```greet()```; это означает, что вы вернулись к функции ```greet()```. При вызове функции ```greet2()``` функция ```greet()``` еще __не была завершена__. Здесь-то и скрывается истинный смысл этого раздела: _когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии_. Все значения переменных этой функции остаются в памяти. А когда выполнение функции ```greet2()``` будет завершено, вы вернетесь к функции ```greet()``` и продолжите ее выполнение с того места, где оно прервалось. Сначала выводится сообщение ```getting ready to say bye...```, после чего вызывается функция ```bye()```.

Блок для этой функции добавляется на вершину стека. Далее выводится сообщение ```ok bye!``` с выходом из вызова функции.

Управление снова возвращается функции ```greet()```. Делать больше нечего, так что управление возвращается и из функции ```greet()```. Этот стек, в котором сохранялись переменные разных функций, называется _стеком вызовов_.

### Стек вызовов с рекурсией

Рекурсивная функция для вычисления факториала выглядит так:

```Python
def fact(x):
  if x == 1:
    return 1
  else:
    return x * fact(x - 1)
```

Стек удобен, но у него есть своя цена: сохранение всей промежуточной информации может привести к значительным затратам памяти. Каждый вызов функции занимает не много памяти, но если стек станет слишком высоким, это будет означать, что ваш компьютер сохраняет информацию по очень многим вызовам. На этой стадии есть 2 варианта:

- Переписать код с использованием цикла.
- Иногда можно воспользоваться так называемой хвостовой рекурсией.

__Упражнение:__

Предположим, вы случайно написали рекурсивную функцию, которая бесконечно вызывает саму себя. Как вы уже видели, компьютер выделяет память в стеке при каждом вызове функции. А что произойдет со стеком при бесконечном выполнении рекурсии?

_Ответ:_

Произойдет насыщение стека, а в свою очередь переполнение стека сигнализирует об ошибке.

Программа выйдет из строя. Обычно стек ограничен операционными системами, чтобы улавливать подобные ошибки до того, как они потребят ВСЮ доступную память.

___

__Шпаргалка:__

- Когда функция вызывает саму себя, это называется рекурсией
- В каждой рекурсивной функции должно быть 2 случая: базовый и рекурсивный
- Стек поддерживает 2 операции: занесение и извлечение элементов
- Все вызовы функций сохраняются в стеке вызовов
- Если стек вызовов станет очень большим, он займет слишком много памяти
